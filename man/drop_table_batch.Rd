% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/drop.R
\name{drop_table_batch}
\alias{drop_table_batch}
\title{Drop a Batch of Tables}
\usage{
drop_table_batch(
  conn,
  conn_fun,
  schema,
  table,
  if_exists = TRUE,
  pattern,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE,
  verbose = TRUE,
  render_sql = TRUE,
  render_only = FALSE,
  ...
)
}
\arguments{
\item{if_exists}{If TRUE, the table will be dropped only if it exists.}

\item{pattern}{character string containing a \link[base]{regular expression}
    (or character string for \code{fixed = TRUE}) to be matched
    in the given character vector.  Coerced by
    \code{\link[base]{as.character}} to a character string if possible.  If a
    character vector of length 2 or more is supplied, the first element
    is used with a warning.  Missing values are allowed except for
    \code{regexpr} and \code{gregexpr}.}

\item{ignore.case}{if \code{FALSE}, the pattern matching is \emph{case
      sensitive} and if \code{TRUE}, case is ignored during matching.}

\item{perl}{logical.  Should Perl-compatible regexps be used?}

\item{fixed}{logical.  If \code{TRUE}, \code{pattern} is a string to be
    matched as is.  Overrides all conflicting arguments.}

\item{useBytes}{logical.  If \code{TRUE} the matching is done
    byte-by-byte rather than character-by-character.  See
    \sQuote{Details}.}

\item{invert}{logical.  If \code{TRUE} return indices or values for
    elements that do \emph{not} match.}

\item{...}{Additional arguments passed to \code{DatabaseConnector::dbSendStatement()}}
}
\description{
Drop a Batch of Tables
}
\examples{
library(pg13)
create_test_schema <-
        function(conn) {

                if (!schema_exists(conn = conn,
                                   schema = "test_schema")) {

                        create_schema(conn = conn,
                                      schema = "test_schema")

                }
        }

conn <- local_connect(dbname = "pg13_test")
create_test_schema(conn = conn)

# Write a table without dropping
write_table(conn = conn,
            schema = "test_schema",
            table_name = "test_table2",
            drop_existing = FALSE,
            data = data.frame(A = 1:3, B = letters[1:3]))

# Write a table with dropping
write_table(conn = conn,
            schema = "test_schema",
            table_name = "test_table",
            drop_existing = TRUE,
            data = data.frame(A = 1:3, B = letters[1:3]))


# Include the name of the dataframe object in the messages
test_data <-
        data.frame(A = 1:3, B = letters[1:3])
write_table(conn = conn,
            schema = "test_schema",
            table_name = "test_table3",
            drop_existing = TRUE,
            data = test_data)

# Append a table
append_table(conn = conn,
             schema = "test_schema",
             table = "test_table",
             data = data.frame(A = 1:3, B = letters[1:3]))

# Warning is returned if NAs are in the input data
append_table(conn = conn,
             schema = "test_schema",
             table = "test_table",
             data = data.frame(A = 1:3, B = rep(NA_character_, 3)))

# Alert is returned if the input data contains 0 rows
test_data2 <-
        data.frame(A = 1,
                   B = 2)
test_data2 <- test_data2[-1,]
append_table(conn = conn,
             schema = "test_schema",
             table = "test_table",
             data = test_data2)

# Message is returned if incoming data contains more than 0 rows
test_data <- read_table(conn = conn,
                           schema = "test_schema",
                           table = "test_table")

test_data

# Alert is returned if incoming data contains 0 rows
write_table(conn = conn,
            schema = "test_schema",
            table_name = "test_table4",
            drop_existing = TRUE,
            data = test_data2)
test_data <- read_table(conn = conn,
                        schema = "test_schema",
                        table = "test_table4")
test_data

search_table(conn = conn,
             schema = "test_schema",
             table = "test_table",
             values = 1:3)

search_table(conn = conn,
             schema = "test_schema",
             table = "test_table",
             values = "a")

search_table(conn = conn,
             schema = "test_schema",
             table = "test_table",
             values = c("A", "b", "C"),
             case_insensitive = FALSE)

drop_table(conn = conn,
           schema = "test_schema",
           table = "test_table",
           if_exists = FALSE)

drop_table(conn = conn,
           schema = "test_schema",
           table = "test_table2",
           if_exists = FALSE)

drop_schema(conn = conn,
            schema = "test_schema",
            cascade = TRUE)

dc(conn = conn)
}
\seealso{
Other table functions: 
\code{\link{appendTable}()},
\code{\link{append_table}()},
\code{\link{create_table_from_df}()},
\code{\link{create_table}()},
\code{\link{drop_all_staging_tables}()},
\code{\link{drop_table}()},
\code{\link{read_table}()},
\code{\link{searchTable}()},
\code{\link{search_table}()},
\code{\link{write_staging_table}()},
\code{\link{write_table}()}

Other drop functions: 
\code{\link{drop_all_staging_tables}()},
\code{\link{drop_cascade}()},
\code{\link{drop_if_exists}()},
\code{\link{drop_schema}()},
\code{\link{drop_table}()}
}
\concept{drop functions}
\concept{table functions}
